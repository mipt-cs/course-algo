Работа в командной строке Linux
#################################

:date: 2018-09-08 09:00
:summary: Работа в командной строке Linux.
:status: published


.. default-role:: code

Введение
========

Kомандный интерпретатор (или командная оболочка) – это программа, принимающая и выполняющая программы. Командный интерпретатор также поддерживает конструкции программирования, позволяя составлять сложные команды из более простых. Эти сложные команды, или сценарии можно сохранять в виде файлов, которые могут становиться новыми самостоятельными командами. В действительности многие команды в обычной Linux-системе являются сценариями.
Мы рассмотрим командный интерпретатор bash – это один из нескольких интерпретаторов, доступных в Linux.

Для ввода данных и вывода результатов интерпретаторы используют три стандартных потока ввода/вывода:

#. `stdin` – стандартный поток ввода (standard input stream), обеспечивающий ввод для команд.
#. `stdout` – стандартный поток вывода (standard output stream), обеспечивающий отображение результатов выполнения команд.
#. `stderr` – стандартный поток ошибок (standard error stream), обеспечивающий отображение ошибок, возникающих при выполнении команд.


При помощи потоков ввода обеспечивается ввод данных для команд (обычно с клавиатуры). Потоки вывода отображают текстовые символы, которые обычно выводятся на экран.

Команды в ОС Linux состоят из имени, опций и параметров. Некоторые команды не имеют ни опций, ни параметров, некоторые имеют и то, и другое, а некоторые – только опции или только параметры. 


Команды
=======

echo
----

Команда echo выводит на экран свои аргументы, как показано в примере ниже

.. code-block:: bash

	[user@comp ~]$ echo Hello World
	Hello World
	[user@comp ~]$ echo Hello      World
	Hello World
	[user@comp ~]$ echo "Hello      World"
	Hello      World
	[user@comp ~]$ echo "Hello      World"  # comment here
	Hello      World
	[user@comp ~]$ echo "\"Hello  World\""  # comment here
	"Hello  World"
	[user@comp ~]$ 

Bash использует символы-разделители, такие как пробелы, символы табуляции и символы новой строки для разделения входной строки на маркеры, которые передаются на вход вашей команде, поэтому в третьей строке все пробелы были сокращены до одного. Чтобы избежать этого, необходимо заключить строку в кавычки – либо в двойные, либо в одинарные.

Другими словами, если строка заключена в кавычки, то все дополнительные символы-разделители сохраняются, и вся строка воспринимается как один маркер. Чтобы использовать кавычки внутри кавычек необходимо использовать символ \\» как показано в последнем примере.

Если строка содержит символ #, то все последующие символы вы этой строке игнорируются.


man
---

По ходу использования операционной системы Linux вам часто будет требоваться информация о том, что делает та или иная команда или системный вызов, какие у них параметры и опции, для чего предназначены некоторые системные файлы, каков их формат и т.д. Получить эту информацию можно при помощи утилиты `man`:

.. code-block:: bash

	man <имя>

где имя – это имя интересующей вас команды, утилиты, системного вызова, библиотечной функции или файла.

Например:

.. code-block:: bash

	man echo

чтобы выйти из man, нажмите клавишу «q».

Иногда имена команд интерпретатора и системных вызовов или какие-либо еще имена совпадают. Тогда чтобы найти интересующую вас информацию, необходимо задать утилите `man` категорию, к которой относится эта информация (номер раздела). Деление информации по категориям может слегка отличаться от одной версии UNIX к другой. В Linux, например, принято следующее разделение:

#. Исполняемые файлы или команды интерпретатора.
#. Системные вызовы.
#. Библиотечные функции.
#. Специальные файлы (обычно файлы устройств).
#. Формат системных файлов и принятые соглашения.
#. Игры (обычно отсутствуют).
#. Макропакеты и утилиты – такие как сам man.
#. Команды системного администратора.
#. Подпрограммы ядра (нестандартный раздел).


Если вы знаете раздел, к которому относится информация, то утилиту man можно вызвать в Linux с дополнительным параметром

.. code-block:: bash

	man <номер_раздела> <имя>

В других операционных системах этот вызов может выглядеть иначе. Для получения точной информации о разбиении на разделы, форме указания номера раздела и дополнительных возможностях утилиты man наберите команду

.. code-block:: bash

	man man


Директории. Команды pwd, ls, cd
-------------------------------

Каждая выполняемая программа «работает» в строго определённой директории файловой системы. Такая директория называется текущей директорией, можно представлять, что программа во время работы «находится» именно в этой директории, это её «рабочее место». В зависимости от текущей директория может меняться поведение программы: зачастую программа будет по умолчанию работать с файлами, расположенными именно в текущей директория — до них она «дотянется» в первую очередь. Текущая директория есть у любой программы, в том числе и у командной оболочки пользователя. Поскольку взаимодействие пользователя с системой обязательно опосредовано командной оболочкой, можно говорить о том, что пользователь «находится» в той директория, которая в данный момент является текущей директорией его командной оболочки.

Все команды, отдаваемые пользователем при помощи `bash`, наследуют текущую директорию `bash`, т. е. «работают» в той же директория. По этой причине пользователю важно знать текущую директория `bash`. Для этого служит утилита `pwd`:

.. code-block:: bash

	[user@comp ~]$ pwd
	/home/user
	[user@comp ~]$

Команда `pwd` возвращает полный путь текущей директории `bash`. В данном случае текущей является директория «/home/user».

Утилиты, которые мы рассмотрим далее, по умолчанию читают и создают файлы в текущей директории.

Для вывода содержимого текущей директории испольузется команда `ls`:

.. code-block:: bash

	[user@comp ~]$ ls
	Desktop    Music       Public     Documents  Downloads
	Pictures    Templates
	[user@comp ~]$

Если указать опцию `-a`, можно будет увидеть все файлы, включая скрытые (имена которых начинаются с точки).

.. code-block:: bash

	[user@comp ~]$ ls -a
	.                   ..                .bash_history
	.icons              .bash_logout      .selected_editor
	.bash_profile       .java             .ssh
	.bashrc             .lesshst          Desktop
	.mc                 Templates         Music
	Documents           Downloads         .nano
	.viminfo            Pictures          Public
	[user@comp ~]$


Первая ссылка указывает на текущую папку (.), вторая (..) указывает на папку уровнем выше. Это открывает еще более широкие возможности для навигации по каталогам. 

После самой команды `ls` в качестве ее аргумента можно указать один или более файлов или директорий. Если указать имя файла, то команда `ls` выведет информацию только об этом файле. А если указать название директории, `ls` покажет все ее содержимое. Опция `-l` команды `ls` бывает очень полезной если вы хотите кроме имен файлов узнать более подробную информацию о них (права на файл, имя владельца, время последнего изменения файла и его размер).
В следующем примере показано применение опции `-l` для вывода информации о файлах хранящихся в директории `/usr`

.. code-block:: bash

	[user@comp ~]$ ls -l /usr
	total 276
	drwxr-xr-x   2 root root 131072 Sep  8 21:25 bin
	drwxr-xr-x   2 root root   4096 Sep  6  2016 games
	drwxr-xr-x  48 root root  20480 Sep  4 22:31 include
	drwxr-xr-x 222 root root  69632 Sep  4 23:35 lib
	drwxr-xr-x  10 root root   4096 Oct  7  2010 local
	drwxr-xr-x   3 root root   4096 Aug 19  2016 locale
	drwxr-xr-x   2 root root  12288 Sep  4 23:35 sbin
	drwxr-xr-x 427 root root  20480 Sep  4 23:35 share
	drwxrwsr-x   6 root src    4096 Sep  8 21:25 src
	[user@comp ~]$

В первой колонке показана информация о правах доступа к каждому файлу в списке. Следующая колонка показывает количество ссылок на каждый элемент списка. Третья и четвертая колонки — владелец и группа файла соответственно. Пятая колонка — размер. Шестая — время последнего изменения файла ('last modified time' или mtime). Последняя колонка — имя файла или директории (Если это ссылка, то после знака «–>» стоит имя объекта на который она ссылается).


Иногда возникает потребность посмотреть информацию только о директориях, а не о всем их содержимом. С этой задачей поможет справиться опция `-d`, которая указывает команде выводить информацию только о директориях.

.. code-block:: bash

	[user@comp ~]$ ls -dl /usr
	drwxr-xr-x 11 root root 4096 Aug 19  2016 /usr

Действие опции `-R` противоположно действию `-d`. Она позволяет выводить информацию о файлах находящихся в директории рекурсивно. Сначала показывается содержимое директории верхнего уровня, потом по очереди содержимое всех поддиректорий и так далее. Вывод этой команды может быть достаточно объемным, поэтому мы не приводим ее пример, но вы можете попробовать сделать это самостоятельно, набрав в командной строке `ls -R` или `ls -Rl`.

Команда cd
----------

Для смены текущей директории командного интерпретатора можно воспользоваться командой `cd`. Для этого необходимо набрать команду в виде

.. code-block:: bash

	cd <имя директории>

где <имя директории> – полное или относительное имя директории, которую вы хотите сделать текущей. Команда `cd` без параметров сделает текущей директорией домашнюю директорию пользователя.

В операционной системе Linux может быть несколько видов путей к файлу:

#. Полный, абсолютный путь linux от корня файловой системы — начинается от корня «/» и описывает весь путь к файлу. Например: «/home/user/myfile»
#. Относительный путь linux — это путь к файлу относительно текущей папки. Например (для файла находящегося в родительской папке): «../myfile». 
#. Путь относительно домашний папки текущего пользователя — путь в файловой системе, только не от корня, а от папки текущего пользователя. Чтобы задать путь подобным образом он должен начинаться с «~/». Например: «~/myfile».


Отделить путь к файлу от его имени можно с помощью команд `dirname` и `basename` соответственно:

.. code-block:: bash

	[user@comp ~]$ basename /home/user/somefile
	somefile
	[user@comp ~]$ basename somefile
	somefile
	[user@comp ~]$ dirname /home/user/somefile
	/home/somefile
	[user@comp ~]$ dirname ./somefile
	.
	[user@comp ~]$ dirname somefile
	.
	[user@comp ~]

Заметим, что для «somefile» и «./somefile» `dirname` выдаёт одинаковый результат: «.», что понятно: как было сказано выше, эти формы пути совершенно эквивалентны, а при автоматической обработке результатов dirname гораздо лучше получить «.», чем пустую строку.


Команда mkdir
-------------

Для создания новой поддиректории используется команда `mkdir`. В простейшем виде команда выглядит следующим образом:

.. code-block:: bash

	mkdir <имя_директории>

По умолчанию команда `mkdir` не может создать вложенной структуры директорий. Поэтому, если вам нужно создать несколько вложенных одна в другую директорий (my/super/dir), то вам придется три раза поочередно вызывать эту команду:

.. code-block:: bash

	[user@comp ~]$ mkdir my/super/dir
	mkdir: cannot create directory 'my/super/dir': No such file or directory
 	[user@comp ~]$ mkdir my
	[user@comp ~]$ mkdir my/super
	[user@comp ~]$ mkdir my/super/dir
	[user@comp ~]$ 

Упростить эту операцию можно добавив опцию 	`-p` к команде `mkdir`. Эта опция позволяет создавать вложенную структуру директорий:

.. code-block:: bash

	[user@comp ~]$ mkdir -p my/super/dir
	[user@comp ~]$

Команда cat
-----------

Команда `cat` может быт использована для просмотра содержимого небольшого текстового файла на экране. Если набрать ее в виде

.. code-block:: bash

	cat <имя файла>

то на экран будет выдано все его содержимое.

Не пытайтесь рассматривать на экране содержимое директорий – все равно не получится. Не пытайтесь просматривать содержимое неизвестных файлов, особенно если вы не знаете, текстовый он или бинарный. Вывод на экран бинарного файла может привести к непредсказуемому поведению терминала.

Если даже ваш файл и текстовый, но большой, то все равно вы увидите только его последнюю страницу. Большой текстовый файл удобнее рассматривать с помощью утилиты `more`:

.. code-block:: bash

	more <текстовый файл>

Если мы в качестве параметров для команды `cat` зададим не одно имя, а имена нескольких файлов

.. code-block:: bash

	cat файл1 файл2 ... файлN

то система выдаст на экран их содержимое в указанном порядке. 


Перенаправление ввода-вывода
----------------------------

Вывод команды cat можно перенаправить с экрана терминала в какой-нибудь файл, воспользовавшись символом перенаправления выходного потока данных – знаком "больше" – ">". Команда

.. code-block:: bash

	cat файл1 файл2 ... файлN > <файл результата>

запишет содержимое всех файлов, чьи имена стоят перед знаком ">", воедино в «файл результата» – конкатенирует их. Прием перенаправления выходных данных со стандартного потока вывода (экрана) в файл является стандартным для всех команд, выполняемых командным интерпретатором. Вы можете получить файл, содержащий список всех файлов текущей директории, если выполните команду ls -a с перенаправлением выходных данных

.. code-block:: bash

	ls -a > <новый файл>

Если имена входных файлов для команды `cat` не заданы, то она будет использовать в качестве входных данных информацию, которая вводится с клавиатуры, до тех пор, пока вы не наберете признак окончания ввода – комбинацию клавиш <CTRL> и <d>.

Таким образом, команда

.. code-block:: bash

	cat > <новый файл>

позволяет создать новый текстовый файл с именем «новый файл» и содержимым, которое пользователь введет с клавиатуры. У команды `cat` существует множество различных опций. Посмотреть ее полное описание можно в UNIX Manual.

Заметим, что наряду с перенаправлением выходных данных существует способ перенаправить входные данные. Если во время выполнения некоторой команды требуется ввести данные с клавиатуры, можно положить их заранее в файл, а затем перенаправить стандартный ввод этой команды с помощью знака "меньше" – "<" и следующего за ним имени файла с входными данными.

Перенаправление с помощью ">" перезаписывает соержимое файла заново. Если нужно дописать в конец, то следует воспользоваться ">>".

Например:

.. code-block:: bash

	[user@comp ~]$ ls -a > list.txt
	[user@comp ~]$ ls -a >> list.txt
	[user@comp ~]$

файл `list.txt` будет содержать результат работы обеих запусков команды `ls`.


Shell скрипты
-------------

Команды исполняемые в bash таккже можно записать в файл и запускать на исполнение. Для этого нужно создать файл (как правило с расширением .sh, например script.sh), первой строкой указать интерпретатор который будет исполнять команды, в нашем случае это

.. code-block:: bash

	#! /bin/bash

и далее поместить исполняемые команды.

Например:

.. code-block:: bash

	#! /bin/bash
	pwd
	ls -al

чтобы файл можно было запускать, установим ему атрибут исполнения при помощи команды `chmod` (будет рассмотрена на следующем занятии): 

.. code-block:: bash

	[user@comp ~]$ chmod a+x ./script.sh
	[user@comp ~]$

и далее запустим

.. code-block:: bash

	[user@comp ~]$ ./script.sh
	<результат работы скрипта>
	[user@comp ~]$

В результате работы скрипта на экран сначала будет выведена текущая директория, а потом ее содержимое.

Чтобы программа, вызывающая скрипт могла проанализировать результат его исполнения, существует такое понятие как код возврата, которое доступно вызывающей программе.

Например:

.. code-block:: bash

	[user@comp ~]$ ls
	<содержимое каталога>
	[user@comp ~]$ echo $?
	0
	[user@comp ~]$ 

Нулевой код возврата означает что вызываемая команда (или скрипт) отработали корректно. Попробуем вывести содержимое несуществующей директории:

.. code-block:: bash

	[user@comp ~]$ ls /abc
	ls: /abc: No such file or directory
	[user@comp ~]$ echo $?
	1
	[user@comp ~]$

Как мы видим, в результате команда `ls` вернула код ошибки 1. 

Каждая команда возвращает код завершения (иногда код завершения называют возвращаемым значением ). В случае успеха команда должна возвращать 0, а в случае ошибки -- ненулевое значение, которое, как правило, интерпретируется как код ошибки. Практически все команды и утилиты UNIX возвращают 0 в случае успешного завершения, но имеются и исключения из правил.

Код возврата последней команды хранится в специальной переменной `$?`. После исполнения кода функции, переменная `$?`` хранит код завершения последней команды, исполненной в функции. Таким способом в bash передается "значение, возвращаемое" функцией. После завершения работы сценария, код возврата можно получить, обратившись из командной строки к переменной `$?`, т.е. это будет код возврата последней команды, исполненной в сценарии.

Аналогичным образом ведут себя функции, расположенные внутри сценария, и сам сценарий, возвращая код завершения. Код, возвращаемый функцией или сценарием, определяется кодом возврата последней команды. Команде `exit` можно явно указать код возврата, в виде: `exit nnn`, где `nnn` -- это код возврата (число в диапазоне 0 - 255).

Когда работа сценария завершается командой `exit` без параметров, то код возврата сценария определяется кодом возврата последней исполненной командой.


Редактор vim
------------

Vim (сокр. от Vi Improved, произносится Вим) — текстовый редактор, созданный на основе более старого Vi. Ныне это один из мощнейших текстовых редакторов с полной свободой настройки и автоматизации.

Режимы работы
~~~~~~~~~~~~~

Существует три основных режима работы: режим команд, режим редактирования и режим последней строки. Переход в режим редактирования клавишами `i` или `insert`, выход из режима редактирования осуществляется клавишей `Esc`. Находясь в режиме команд, можно выполнять сложные операции редактирования текста с помощью клавиши "двоеточие"(:). При нажатии этой клавиши курсор устанавливается в последнюю строку экрана, поэтому данный режим называется режимом последней строки. Он считается особым типом режима команд.

Для того, чтобы открыть какой-то файл или создать новый надо выполнить команду:

.. code-block:: bash

	[user@comp ~]$  vi <имя файла>

Затем можно нажать клавишу `i` (или `insert`) и внести нужные изменения.
Если вместо `i` нажать `a`, текст будет вставляться за символом на котором стоит курсор (обычно используется при редактировании файлов этот метод), если нажать `o` - будет вставлена новая строка.

Стирать текст следует выйдя из режима редактирования клавишей `Esc` и затем можно использовать клавишу `x` - она работает как клавиша `del` - стирает вперед, если нажимать `shift+x`, то будет стирать назад (по аналогии с `backspace`)

После редактирования нажмите `(esc):wq` чтобы выйти с сохранением текста.

Более подробно о vim можно прочитать в `учебнике`__. 

.. __: http://rus-linux.net/MyLDP/BOOKS/Vim/prosto-o-vim.pdf


Самостоятельная работа
======================

#. Напишите скрипт `absolute.sh`, который в независимости от того, в какой директории запущен, создает файл `/tmp/hello world/absolute.txt`, содержащий текст 'hello world!!', выводит на экран его содержимое и атрибуты. Запустите скрипт.
#. Напишите скрипт `home.sh`, который в независимости от того, в какой директории запущен, создает файл `<домашняя директория пользователя>/hello home/home.txt`, содержащий текст 'hello home!!', выводит на экран его содержимое и атрибуты. Запустите скрипт.
#. Напишите скрипт `current.sh`, который в независимости от того, в какой директории запущен, создает файл `<текущая директория>/hello current/current.txt`, содержащий текст 'hello current!!', выводит на экран его содержимое и атрибуты. Запустите скрипт.
#. Напишите скрипт `parent.sh`, который в независимости от того, в какой директории запущен, создает файл `<родительская директория>/hello parent/parent.txt`, содержащий текст 'hello parent!!', выводит на экран его содержимое и атрибуты. Запустите скрипт.

